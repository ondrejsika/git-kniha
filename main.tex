\documentclass[12pt,a5paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=2cm]{geometry}
\usepackage[parfill]{parskip}
\usepackage{listings}
\lstset{
   breaklines=true,
   basicstyle=\ttfamily}

\title{Git kniha}
\author{Ondrej Sika}
\date{2015}

\begin{document}
\include{intro}

\section{Predmluva}

Proc jsem se rozhodl psat knizku o Gitu, kdyz je jich vsude plno? A kdyz je i slavna Pro Git od Scotta Sharona prelozena a zdarma dostupna na \lstinline|https://knihy.nic.cz/|. Tyto knizku jsou urcene programatorum a vetsina jich je hodne pokrocilich, ja se v teto knize budu snazit ukazat jak Git funguje prevazne neprogramatorum pripadne zacinajicim programatorum. Verim ze Git je vhodny i pro lidi, kteri napriklad pisi nejake prace, prezentace a nemusi byt vubec programatori.

Git ma mnoho grafickych nastaveb, ale ja verim, ze pokud si clovek osaha ovladani z terminalu, nakonec to pro nej bude nejlepsi. Proto v teto knizce budu vse ovladat z terminalu, shlellu a nebudu se zabyvat klikatky. Pokud je pro vas Shell neco uplne noveho, kouknete se na {\bf Ondrej~Sika:~Shell~kniha} (\lstinline|https://ondrejsika.com/books/shell-kniha|). Budu se ovsem snazit nejnutnejsi minimum popsat i v teto knize.

\section{Co je to Git}

Git je verzovaci system, ktery je primarne urcen pro verzovani kodu. Ale muzeme jim verzovat prakticky cokoliv. Git je velmi rozsireny (dnes uz majoritni) verzovaci system a pro kazdeho programatora je jeho znalost naprostou nutnosti. Jeho hlavni vyhody jsou moznost spoluprace nad jednim kodem ve vice lidech, prace na ruzmych castech kodu bezpecne v oddelenych vetvich a revize kodu.

\section{Vytvoreni repozitare}

Repozitar se vytvari bud prikazem \lstinline|git init| a nebo se naklonuje. O klonovaci bude rec v kapotole vzdalene repozitare.

Pokud chceme v nekterem adresari vytvorit repozitar, staci zavolat prikaz \lstinline|git init|.

Priklad:

\begin{lstlisting}
sika@sika:~$ mkdir myrepo
sika@sika-mol:~$ cd myrepo
sika@sika:~/myrepo$ git init
Initialized empty Git repository in /home/sika/myrepo/.git/
sika@sika:~/myrepo (master)$
\end{lstlisting}

\section{Gitignore}

Pred tim, nez zacneme s repozitarem pracovat, je dobre Gitu rici o jake soubory se nema zajimat. Jsou to soubory docasne, napriklad zalohy editoru, nastavenu prostredi ci zkompilovane programy. Ty verzovat nemusime a ani nechceme. Proto je vhodne zjistit, jake soubory v repozitari nechceme jeste pred tim, nez s nim zacneme pracovat. Napriklad, kdyz budu psat knizku v LaTeXu tak chci verzovat jen .tex soubory a vystupni .pdf ne (ten si kazdy vytvori sam z .tex zdroju). LaTeX ale pri generovani vytvari jeste .aux, .log a .toc. Dale vim, ze budu knizku psat ve Vimu, ktery vytvari soubory .swp. Vsechny proto napisu do souboru \lstinline|.gitignore| (tecka na zacatku znamena v Unix svete skryty soubor/slozka). Kdyz chci ignorovat vsechny soubory s priponou .pdf, napisi do gitignore \lstinline|*.pdf| Nas soubor bude potom vypadat takto:

\begin{lstlisting}
*.swp
*.aux
*.log
*.toc
*.pdf

\end{lstlisting}


\section{3 stavy}
\section{Commit}
\section{Vetve}

Nejdrive co jsou to vetve. Muzeme si to predstavit ze pracujeme na 2 ruznych castich projektu aniz by se mezi sebou ovlivnovali. Jsou nezavisle az do te doby co se je rozhodneme sloucit. Prace s vetvemi je dulezita a git ji ma vyresenou velmi efektivne a je rychla.

Doted jsme pracovali pouze ve vetvi {\bf master}. Prikaz \lstinline|git branch| nam vypise lokalni vetve a oznaci nam hvezdickou aktualni vetev.

\begin{lstlisting}
sika@sika:~/myrepo (master)$ git branch
* master
\end{lstlisting}

Jak si muzete vsimnout, muj prompt shellu sam ukazuje aktualni vetev, v zavorkach.

Pokud chci vytvorit novou vetev, pouziji prikaz \lstinline|git branc <name>| kde name je nazev nove vetve. Vetve je rozumne pojmenovavat podle toho co v nic chceme delat, ale nazev se vzdy da zmenit.

Pri praci s vetvemi doporucuji mit cisty working directory, toho muzeme jednoduse docilit prikazem \lstinline|git stash|, jak uz vime.

\begin{lstlisting}
sika@sika:~/myrepo (master)$ git branch experimental
sika@sika:~/myrepo (master)$ git branch
  experimental
* master
sika@sika:~/myrepo (master)$
\end{lstlisting}

Vetev jsme sice vytvorili, ale porad zustavame na te puvodni. V nekdterych pripadech to plati, ze si vytvorime vetev jen jako zalohu a pokracujeme v praci, ale v typickem pripade je to obracene. Vytvarime novou vetev abychom v ni delali nejakou slozitejsi praci.

Pro prepnuti pouzijeme prikaz \lstinline|git checkout <name>|, ktery nas prepne na danou vetev.

\begin{lstlisting}
sika@sika:~/myrepo (master)$ git checkout experimental
Switched to branch 'experimental'
sika@sika:~/myrepo (experimental)$ git branch
* experimental
  master
sika@sika:~/myrepo (experimental)$
\end{lstlisting}

Pokud se chceme prepnot do neexistujici vetve, git vypise chybu:

\begin{lstlisting}
sika@sika:~/myrepo (master)$ git checkout new
error: pathspec 'new' did not match any file(s) known to git.
\end{lstlisting}

Kdyz ovsem chceme vetev vytvorit a rovnou se do ni prepnout, coz je podle me nejcastejsi pouziti, pouzijeme prikaz git checkout s parametrem -b:

\begin{lstlisting}
sika@sika:~/myrepo (master)$ git branch
* master
sika@sika:~/myrepo (master)$ git checkout -b new
Switched to a new branch 'new'
sika@sika:~/myrepo (new)$ git branch
  master
* new
sika@sika:~/myrepo (new)$
\end{lstlisting}

Uz vime jak vetve vytvaret a prepinat, jeste je potreba umet vetev smazat. Prikaz pro smazani vetve je \lstinline|git branch -d <name>|. Nemuzeme ovsem smazat vetev na ktere se aktualne nachazime.

\begin{lstlisting}
sika@sika:~/myrepo (new)$ git branch
  master
* new
sika@sika:~/myrepo (new)$ git checkout master
Switched to branch 'master'
sika@sika:~/myrepo (master)$ git branch -d new
Deleted branch new (was 3a612f1).
sika@sika:~/myrepo (master)$ git branch
* master
\end{lstlisting}

Ted uz je na case zacit vetve pouzivat, uvidite, ulehci vam praci. Umozni vam totiz v jedne vetvi prestat a v jine pokracovat na uplne jine casti vaseho projektu. Klidne muzete ve dvou vetvich delat to a same najednou a potom vybrat tu vetev s lepsim resenim a pouzit ji a druhou smazat.


\subsection{Merge}
\subsection{Rebase}
\section{Vzdalene repozitare}
\section{Github}
\section{Alternativy}

Alternativ ke Githubu je mnoho, ja zde uvedu pouze 2, ktere jsou podle me vyznamne a stoji za to je zminit. Prvni alternativou je Bitbucket (\lstinline|https://bitbucket.org|). Je to take sluzba jako Github s tim rozdilem, ze se neplati za pocet privatnich repozitaru, ale za pocet kolaborantu (lidi co pracuji na danem projektu). Pokud tedy potrebujete privatni repozitare, tak do 5 spolupracovniku je to take zdarma.

Dalsi alternativou je Gitlab. Ten je opensource a muzete si ho jednoduse spaustit na vlastnim serveru a vase data budou pouze u vas. Existuje i v hostovane verzi na \lstinline|https://gitlab.com|. Gitlab ma tu vyhodu, ze nema zadne omezeni na pocet kolaborantu ani na pocet privatnich repozitaru.

Proc je Bitbucket tak rozsireny, i kdyz umi zdarma pouze cast toho co umi Gitlab? Na to je jednoducha odpoved, Gitlab je pomerne novy a dlouho to byla jedina moznost jak mit zdarma privatni repozitare.

Osobne pouzivam na opensource projekty Github kvuli komunite (issues, pullrequesty, ...) a na privatni projekty si sam hostuji Gitlab.

%\begin{thebibliography}{10}
%  \bibitem{python-kniha}Ondrej Sika:
%    {\em Python kniha}.\\
%    Sika Press, Praha, 2015.\\
%    ISBN 80-85867-35-4.\\
%    \lstinline|https://ondrejsika.com/books/python-kniha|
%  \bibitem{homesim}Ondrej Sika:
%    {\em Latex paper examples}. (brezen 2015).\\
%    \lstinline|https://ondrejsika.com/others/latex/|
%  \bibitem{wiki-shell} Wikipedia:
%    \emph{Shell (Programovani)}. (brezen 2015).\\
%    \lstinline|https://cs.wikipedia.org/wiki/Shell_(programov%C3%A1n%C3%AD)|
%\end{thebibliography}
\end{document}

